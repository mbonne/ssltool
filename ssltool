#!/bin/bash

###===============================================================##
##
##            Name:  ssltool
##          Author:  mbonne
##         Purpose:  CLI tool which uses builtin binary, to create private key, csr, validate md5 hash of certs
##         Created:  2022-05-01
##   Last Modified:
##         Version:  1
##    Source Notes:
##
##
##
###===============================================================##

## Setup the colour codes.
RED="\033[1;31m"
GREEN="\033[1;32m"
NOCOLOR="\033[0m"
##usage -> echo -e "${GREEN}text-goes-here${NOCOLOR}\n"
## \n for newline

###==========================VARIABLES============================##

###===============================================================##
#[[ -n "$csrFile" ]] && openssl req -text -noout -verify -in "$csrFile" 
#[[ -n "$pubKey" ]] && openssl x509 -in "$pubKey" -text -noout
#[[ -n "$privKey" ]] && openssl rsa -in "$privKey" -check

###==========================FUNCTIONS============================##
## Option 1

#TODO: Option to use existing Private Key or generate new key.

function generateCSR(){
  #REMOVE LINE BELOW WHEN THIS OPTION WORKS :)
  echo -e "${RED}->THIS OPTION DOESN'T WORK YET<-${NOCOLOR}"

  echo -e "${GREEN}Collecting info to build CSR.\n\
  There is no error checking.\n\
  Check your spelling and DNS is correct.${NOCOLOR}"
  #Subject: CN=access.henry.com.au, O=Henry Care, C=AU, L=Sydney, ST=NSW
  commonName=""
  sanNames=""
  organisationName=""
  countryCode="AU"
  stateName="NSW"
  cityName="Sydney"
  
#------------------COMMON NAME------------------#
  echo -e "\n---------------------------------------\n"
  while true; do
    read -e -r -p "Enter FQDN of Host: " commonName
    if [  -z "$commonName" ] ; then
      echo -e "${RED}Enter the FQDN of your Host.\n\
      Example: domain.com or server.domain.com or *.domain.com\n${NOCOLOR}" >&2
    else
      break
    fi
  done

#------------------SAN NAMES-------------------#

  echo -e "\n---------------------------------------\n"
  echo -e "Enter additional host names you want the certificate to cover\n\
  each SAN should be separated with a space.\n"
  read -e -r -p "Enter SAN for Certificate: " sanNames

#---------------ORGANISATION NAME---------------#

  echo -e "\n---------------------------------------\n"
  while true; do
    read -e -r -p "Enter Company Name of Host: " organisationName
    if [  -z "$organisationName" ] ; then
      echo -e "${RED}Enter the Company Name.\n${NOCOLOR}" >&2
    else
      break
    fi
  done

#------------------COUNTRY NAME-------------------#

  echo -e "\n---------------------------------------\n"
  echo -e "Leave blank for Default:${GREEN} $countryCode${NOCOLOR}\n"
  read -e -r -p "Enter Country Code: " usersCountryCode
  usersCountryCode=${usersCountryCode:-${countryCode}}

#-------------------STATE NAME--------------------#

  echo -e "\n---------------------------------------\n"
  echo -e "Leave blank for Default:${GREEN} $stateName${NOCOLOR}\n"
  read -e -r -p "Enter Country Code: " usersStateName
  usersStateName=${usersStateName:-${stateName}}

#-------------------CITY NAME---------------------#

  echo -e "\n---------------------------------------\n"
  echo -e "Leave blank for Default:${GREEN} $cityName${NOCOLOR}\n"
  read -e -r -p "Enter Country Code: " usersCityName
  usersCityName=${usersCityName:-${cityName}}

#-------------------CSR DETAILS---------------------#
#TODO: Provide user option to continue or quit.
  echo -e "\n---------------------------------------\n"
  echo -e "${GREEN} You have entered:${NOCOLOR}\n\
  $commonName\n\
  $sanNames\n\
  $organisationName\n\
  $usersCountryCode\n\
  $usersStateName\n\
  $usersCityName\n"



}

###===============================================================#####===============================================================##
## Option 2

function checkCertFiles(){
  read -e -r -p "Enter Path To CSR file(.csr): " csrFile
  read -e -r -p "Enter Path To Public Key(.crt or .pem): " pubKey
  read -e -r -p "Enter Path To Private Key(.key or .pem): " privKey
 
  echo -e "${GREEN}Printing md5 Hash of each file targeted:${NOCOLOR}\n"

  ##TODO: Work out how to compare all array values and make sure they're the same. An IF statement can only compare 2 things at a time.

  declare -a hashArray
  hashArray+=("$([ -f "$csrFile" ] && openssl req -noout -modulus -in "$csrFile" | openssl md5)")
  hashArray+=("$([ -f "$pubKey" ] && openssl x509 -noout -modulus -in "$pubKey" | openssl md5)")
  hashArray+=("$([ -f "$privKey" ] && openssl rsa -noout -modulus -in "$privKey" | openssl md5)")

  for i in ${hashArray[*]}
  do
    echo -e "$i"
  done

  echo -e "\nAll md5 vaules shown need to match.\n"


}
###===============================================================#####===============================================================##
## Option 3

function showCSRDetails {
  while true; do
    read -e -r -p "Enter Path To .csr file: " csrFile
    if [[ $csrFile != *.csr ]]; then
      echo -e "${RED}File type should be .csr.\nRe-Enter file path to your CSR file${NOCOLOR}" >&2
    else
      openssl req -text -noout -verify -in "$csrFile"
      echo -e "${GREEN}\n\
      Double check your Common Name(CN) and Subject Alternative Names(SAN)\n\
      Be sure to validate Private Key Hash against this CSR.\n\
      You can re-run this script and select Option 2 to validate hash vaulues.${NOCOLOR}"
      break
    fi
  done
}

###===============================================================#####===============================================================##
## Option 4

function showSSL {
  while true; do
    read -e -r -p "Enter host FQDN: " hostURL
    ipAddress="$(dig "$hostURL" +short)"

    if [ -z "$ipAddress" ]; then
      echo -e "${RED}dig could not verify host.\nDon't include https:// if you have${NOCOLOR}" >&2

    #if ! dig "$hostURL" +short > /dev/null 2>&1; then
      #echo -e "${RED}Couldn't verify host FQDN.\nDon't include https://${NOCOLOR}" >&2
    else
      echo -e "${GREEN}Checking SSL Certificate:${NOCOLOR} $1"
      echo | openssl s_client -showcerts -servername "$hostURL" -connect "$hostURL":443 2>/dev/null | openssl x509 -inform pem -noout -text
      sslInfo="$(curl --insecure -vvI https://"$hostURL" 2>&1 | awk 'BEGIN { cert=0 } /^\* SSL connection/ { cert=1 } /^\*/ { if (cert) print }')"
      echo "$sslInfo"

      if [[ $sslInfo != *"SSL certificate verify ok."* ]]; then
        echo -e "${RED}Check Certificate Validity!${NOCOLOR}"
        exit 1
      fi
      break
      fi
  done

  }

###===============================================================#####===============================================================##
PS3='Select SSL operation: '
options=("Generate CSR" "Validate Cert Hash" "Show CSR Details" "Check SSL On Host" "Quit")
select opt in "${options[@]}"
do
  case $opt in
    "Generate CSR")
      echo "Preparing Certificate Signing Request"
      generateCSR "$@"
      break
      ;;
    "Validate Cert Hash")
      echo "Comparing md5 values for targeted files"
      checkCertFiles "$@"
      break
      ;;
    "Show CSR Details")
      echo -e "${GREEN}Showing details of targeted Certificate Signing Request file${NOCOLOR}"
      showCSRDetails "$@"
      break
      ;;
    "Check SSL On Host")
      echo -e "${GREEN}Checking the certificate and validity status of target host.${NOCOLOR}"
      showSSL "$@"
      break
      ;;
    "Quit")
      echo -e "${RED} SSL Tool Aborted${NOCOLOR}"
      exit 0
      ;;
    *) echo -e "${RED} invalid option $REPLY${NOCOLOR}";;
  esac
done

###===============================================================#####===============================================================##

#calculatedHash=$hashOption
#taking the user inputted correctHash and converts to lowercase in the event website displays the hash all in CAPs
#lowerCaseHash=$(echo "$correctHash" | tr '[:upper:]' '[:lower:]')

#if [[ "${calculatedHash}" == "${lowerCaseHash}" ]]; then
#  echo -e "\033[33;32m The Hash looks good."
#  echo -e "\033[33;32m Correct Hash:    $correctHash"
#  echo -e "\033[33;32m Your files Hash: $calculatedHash"
#else
#  echo -e "\033[33;31m Uh Oh Hash does not match..." # RED \033[33;31m
#  echo -e "\033[33;32m The Correct Hash: $correctHash" # GREEN \033[33;32m
#  echo -e "\033[33;31m Your files Hash:  $calculatedHash"
#fi

exit $?

